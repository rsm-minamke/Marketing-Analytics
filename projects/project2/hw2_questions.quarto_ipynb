{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Poisson Regression Examples\"\n",
        "author: \"Mrunmayee Inamke\"\n",
        "date: today\n",
        "callout-appearance: minimal # this hides the blue \"i\" icon on .callout-notes\n",
        "format:\n",
        "  html:\n",
        "    code-fold: true\n",
        "    math: true\n",
        "---\n",
        "\n",
        "## Blueprinty Case Study\n",
        "\n",
        "### Introduction\n",
        "\n",
        "Blueprinty is a small firm that makes software for developing blueprints specifically for submitting patent applications to the US patent office. Their marketing team would like to make the claim that patent applicants using Blueprinty's software are more successful in getting their patent applications approved. Ideal data to study such an effect might include the success rate of patent applications before using Blueprinty's software and after using it. Unfortunately, such data is not available. \n",
        "\n",
        "However, Blueprinty has collected data on 1,500 mature (non-startup) engineering firms. The data include each firm's number of patents awarded over the last 5 years, regional location, age since incorporation, and whether or not the firm uses Blueprinty's software. The marketing team would like to use this data to make the claim that firms using Blueprinty's software are more successful in getting their patent applications approved.\n",
        "\n",
        "\n",
        "### Data\n",
        ":::: {.callout-note collapse=\"true\"}"
      ],
      "id": "02a8569f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import pandas as pd\n",
        "df = pd.read_csv(\"blueprinty.csv\")\n",
        "df.head()"
      ],
      "id": "4e4d42c0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::::\n",
        "\n",
        ":::: {.callout-note collapse=\"true\"}"
      ],
      "id": "4d395a72"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "sns.set(style=\"whitegrid\")\n",
        "plt.figure(figsize=(8, 6))\n",
        "sns.histplot(data=df, x=\"patents\", hue=\"iscustomer\", bins=20, multiple=\"dodge\")\n",
        "plt.title(\"Number of Patents by Customer Status\")\n",
        "plt.xlabel(\"Number of Patents\")\n",
        "plt.ylabel(\"Number of Firms\")\n",
        "plt.legend(title=\"Is Customer\", labels=[\"Non-Customer\", \"Customer\"])\n",
        "plt.show()"
      ],
      "id": "7d7543ff",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::::\n",
        "\n",
        "\n",
        "### Means of Number of Patents by Customer Status\n",
        ":::: {.callout-note collapse=\"true\"}"
      ],
      "id": "d888a5cf"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "df.groupby(\"iscustomer\")[\"patents\"].mean()"
      ],
      "id": "98c0e6b7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::::\n",
        "\n",
        "### Observation\n",
        "\n",
        "Firms that are customers of Blueprinty tend to have more patents on average (≈ 4.13) than non-customers (≈ 3.47). The histogram shows that customer firms are more concentrated at higher patent counts, suggesting a potential positive relationship between using Blueprinty and patent success. However, this pattern may also be influenced by other factors, such as region or firm age, which need to be explored further.\n",
        "\n",
        "Blueprinty customers are not selected at random. It may be important to account for systematic differences in the age and regional location of customers vs non-customers.\n",
        "\n",
        "### Compare Regions and Ages by Customer Status\n",
        "\n",
        "### Region Distribution by Customer Status\n",
        ":::: {.callout-note collapse=\"true\"}"
      ],
      "id": "a3b95a94"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import seaborn as sns\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "palette = {0: \"#4C72B0\", 1: \"#DD8452\"}\n",
        "plt.figure(figsize=(8, 6))\n",
        "sns.countplot(data=df, x=\"region\", hue=\"iscustomer\", palette=palette)\n",
        "plt.title(\"Region Distribution by Customer Status\")\n",
        "plt.xlabel(\"Region\")\n",
        "plt.ylabel(\"Number of Firms\")\n",
        "plt.legend(title=\"Is Customer\", labels=[\"Non-Customer\", \"Customer\"])\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "85119b09",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::::\n",
        "\n",
        "### Firm Age by Customer Status\n",
        ":::: {.callout-note collapse=\"true\"}"
      ],
      "id": "3cebc108"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Map customer status labels\n",
        "df[\"Customer Status\"] = df[\"iscustomer\"].map({0: \"Non-Customer\", 1: \"Customer\"})\n",
        "\n",
        "# Define matching palette\n",
        "palette = {\"Non-Customer\": \"#4C72B0\", \"Customer\": \"#DD8452\"}\n",
        "\n",
        "# Plot\n",
        "plt.figure(figsize=(8, 6))\n",
        "sns.boxplot(data=df, x=\"Customer Status\", y=\"age\", hue=\"Customer Status\", palette=palette, legend=False)\n",
        "plt.title(\"Firm Age by Customer Status\")\n",
        "plt.xlabel(\"Is Customer\")\n",
        "plt.ylabel(\"Firm Age (Years)\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "301e9443",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::::\n",
        "\n",
        "### Mean of ages by Customer Status\n",
        ":::: {.callout-note collapse=\"true\"}"
      ],
      "id": "5be2c972"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "df.groupby(\"iscustomer\")[\"age\"].mean()"
      ],
      "id": "a82903d3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::::\n",
        "\n",
        "### Observation\n",
        "The regional distribution of firms is not uniform between customers and non-customers. Some regions (e.g., Northeast) have a higher concentration of Blueprinty customers. This suggests that region may confound the relationship between software usage and patent outcomes.\n",
        "\n",
        "Regarding age, customers are slightly older on average (~26.9 years) than non-customers (~26.1 years), though the difference is modest. It is still important to consider firm age in the analysis to avoid biased conclusions.\n",
        "\n",
        "### Estimation of Simple Poisson Model\n",
        "Since our outcome variable of interest can only be small integer values per a set unit of time, we can use a Poisson density to model the number of patents awarded to each engineering firm over the last 5 years. We start by estimating a simple Poisson model via Maximum Likelihood.\n",
        "\n",
        "\n",
        "### Likelihood for Poisson Distribution\n",
        "\n",
        "**Probability Mass Function**\n",
        "\n",
        "The probability mass function for a single observation from a Poisson distribution is:\n",
        "\n",
        "$$\n",
        "f(Y_i \\mid \\lambda) = \\frac{e^{-\\lambda} \\lambda^{Y_i}}{Y_i!}\n",
        "$$\n",
        "\n",
        "**Likelihood Function**\n",
        "\n",
        "Assuming the observations are independent, the likelihood function for the entire dataset is:\n",
        "\n",
        "$$\n",
        "L(\\lambda; Y_1, \\ldots, Y_n) = \\prod_{i=1}^{n} \\frac{e^{-\\lambda} \\lambda^{Y_i}}{Y_i!}\n",
        "$$\n",
        "\n",
        "This can be rewritten as:\n",
        "\n",
        "$$\n",
        "L(\\lambda) = e^{-n\\lambda} \\cdot \\lambda^{\\sum_{i=1}^{n} Y_i} \\cdot \\prod_{i=1}^{n} \\frac{1}{Y_i!}\n",
        "$$\n",
        "\n",
        "**Log-Likelihood Function**\n",
        "\n",
        "Taking the natural logarithm of the likelihood gives:\n",
        "\n",
        "$$\n",
        "\\log L(\\lambda) = -n\\lambda + \\left( \\sum_{i=1}^{n} Y_i \\right) \\log \\lambda - \\sum_{i=1}^{n} \\log(Y_i!)\n",
        "$$\n",
        "\n",
        "This log-likelihood will be used to estimate \\( \\lambda \\) via Maximum Likelihood Estimation (MLE).\n",
        "\n",
        "### Poisson Log Likelihood Function\n",
        ":::: {.callout-note collapse=\"true\"}"
      ],
      "id": "6045f6b6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "from scipy.special import gammaln\n",
        "\n",
        "# Define the Poisson log-likelihood function\n",
        "def poisson_loglikelihood(lambd, Y):\n",
        "    if lambd <= 0:\n",
        "        return -np.inf  # log-likelihood is undefined for non-positive lambda\n",
        "    return np.sum(-lambd + Y * np.log(lambd) - gammaln(Y + 1))"
      ],
      "id": "14c51f61",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::::\n",
        "\n",
        "We visualize the Poisson log-likelihood as a function of \\( \\lambda \\), where the maximum corresponds to the MLE.\n",
        "\n",
        ":::: {.callout-note collapse=\"true\"}"
      ],
      "id": "331d4338"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "from scipy.special import gammaln\n",
        "\n",
        "# Example data: simulated Poisson observations\n",
        "Y_sample = df[\"patents\"].values\n",
        "\n",
        "# Range of lambda values to plot\n",
        "lambdas = np.linspace(0.1, 10, 300)\n",
        "log_likelihoods = [poisson_loglikelihood(l, Y_sample) for l in lambdas]\n",
        "\n",
        "# Find MLE visually\n",
        "lambda_mle = lambdas[np.argmax(log_likelihoods)]\n",
        "\n",
        "# Plot\n",
        "plt.figure(figsize=(8, 6))\n",
        "plt.plot(lambdas, log_likelihoods, linewidth=2, color=\"steelblue\")\n",
        "plt.axvline(lambda_mle, color=\"darkorange\", linestyle=\"--\", label=f\"MLE ≈ {lambda_mle:.2f}\")\n",
        "plt.title(\"Poisson Log-Likelihood vs. Lambda\", fontsize=14, weight=\"bold\")\n",
        "plt.xlabel(\"Lambda\", fontsize=12)\n",
        "plt.ylabel(\"Log-Likelihood\", fontsize=12)\n",
        "plt.grid(True, linestyle=\"--\", alpha=0.5)\n",
        "plt.legend()\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "5f44c7ec",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::::\n",
        "\n",
        "### Derivation of the MLE for Poisson Distribution\n",
        "\n",
        "Suppose \\( Y_1, Y_2, \\ldots, Y_n \\sim \\text{Poisson}(\\lambda) \\), where the probability mass function is:\n",
        "\n",
        "$$\n",
        "f(Y_i \\mid \\lambda) = \\frac{e^{-\\lambda} \\lambda^{Y_i}}{Y_i!}\n",
        "$$\n",
        "\n",
        "**Step 1: Log-Likelihood Function**\n",
        "\n",
        "The log-likelihood of the entire sample is:\n",
        "\n",
        "$$\n",
        "\\log L(\\lambda) = \\sum_{i=1}^{n} \\left( -\\lambda + Y_i \\log \\lambda - \\log Y_i! \\right)\n",
        "$$\n",
        "\n",
        "We can simplify this (since \\( \\log Y_i! \\) does not depend on \\( \\lambda \\)):\n",
        "\n",
        "$$\n",
        "\\log L(\\lambda) = -n\\lambda + \\left( \\sum_{i=1}^{n} Y_i \\right) \\log \\lambda + \\text{constant}\n",
        "$$\n",
        "\n",
        "**Step 2: First Derivative**\n",
        "\n",
        "Take the derivative with respect to \\( \\lambda \\):\n",
        "\n",
        "$$\n",
        "\\frac{d}{d\\lambda} \\log L(\\lambda) = -n + \\frac{1}{\\lambda} \\sum_{i=1}^{n} Y_i\n",
        "$$\n",
        "\n",
        "**Step 3: Set Derivative to Zero**\n",
        "\n",
        "$$\n",
        "-n + \\frac{1}{\\lambda} \\sum_{i=1}^{n} Y_i = 0\n",
        "$$\n",
        "\n",
        "Solving for \\( \\lambda \\):\n",
        "\n",
        "$$\n",
        "\\lambda = \\frac{1}{n} \\sum_{i=1}^{n} Y_i = \\bar{Y}\n",
        "$$\n",
        "\n",
        "The maximum likelihood estimator (MLE) of \\( \\lambda \\) is the sample mean:\n",
        "\n",
        "$$\n",
        "\\hat{\\lambda}_{\\text{MLE}} = \\bar{Y}\n",
        "$$\n",
        "\n",
        "This result makes intuitive sense: in a Poisson distribution, the mean and variance are both equal to \\( \\lambda \\), so the best estimate of \\( \\lambda \\) from data is the observed average.\n",
        "\n",
        "### Maximum Likelihood Estimation using `scipy.optimize`\n",
        "\n",
        "We use numerical optimization to find the value of \\( \\lambda \\) that maximizes the Poisson log-likelihood.\n",
        "\n",
        ":::: {.callout-note collapse=\"true\"}"
      ],
      "id": "1226ac03"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from scipy import optimize\n",
        "neg_loglikelihood = lambda lambd: -poisson_loglikelihood(lambd[0], Y_sample)\n",
        "result = optimize.minimize(neg_loglikelihood, x0=[1.0], bounds=[(1e-6, None)])\n",
        "lambda_mle = result.x[0]\n",
        "lambda_mle"
      ],
      "id": "fd88b0df",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::::\n",
        "\n",
        "### Interpretation\n",
        "\n",
        "The maximum likelihood estimate (MLE) of \\( \\lambda \\) is approximately equal to the sample mean of the number of patents, which is expected for a Poisson distribution."
      ],
      "id": "b184be45"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Compare with the sample mean\n",
        "df[\"patents\"].mean()"
      ],
      "id": "715d1c75",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Estimation of Poisson Regression Model\n",
        "\n",
        "Next, we extend our simple Poisson model to a Poisson Regression Model such that $Y_i = \\text{Poisson}(\\lambda_i)$ where $\\lambda_i = \\exp(X_i'\\beta)$. The interpretation is that the success rate of patent awards is not constant across all firms ($\\lambda$) but rather is a function of firm characteristics $X_i$. Specifically, we will use the covariates age, age squared, region, and whether the firm is a customer of Blueprinty.\n",
        "\n",
        "::::{.callout-note collapse=\"true\"}"
      ],
      "id": "d79145ec"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "from scipy.special import gammaln\n",
        "\n",
        "# Define Poisson regression log-likelihood function\n",
        "def poisson_regression_loglike(beta, X, Y):\n",
        "    Xbeta = X @ beta\n",
        "    lambdas = np.exp(Xbeta)\n",
        "    return np.sum(-lambdas + Y * Xbeta - gammaln(Y + 1))"
      ],
      "id": "2ad2734e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::::\n",
        "\n",
        "### To find the MLE vector using `scipy.optimize`\n",
        "\n",
        "::::{.callout-note collapse=\"true\"}"
      ],
      "id": "d85422ef"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import pandas as pd\n",
        "import numpy as np\n",
        "from scipy import optimize\n",
        "from scipy.special import gammaln\n",
        "\n",
        "# Load the data\n",
        "df = pd.read_csv(\"blueprinty.csv\")\n",
        "\n",
        "# Create age squared\n",
        "df[\"age2\"] = df[\"age\"] ** 2\n",
        "\n",
        "# Create region dummies (drop one to avoid multicollinearity)\n",
        "region_dummies = pd.get_dummies(df[\"region\"], drop_first=True)\n",
        "\n",
        "# Construct design matrix\n",
        "X = pd.concat([\n",
        "    pd.Series(1, index=df.index, name=\"intercept\"),\n",
        "    df[\"age\"],\n",
        "    df[\"age2\"],\n",
        "    region_dummies,\n",
        "    df[\"iscustomer\"]\n",
        "], axis=1)\n",
        "\n",
        "Y = df[\"patents\"].values\n",
        "X_matrix = X.values\n",
        "def poisson_loglike(beta, X, Y):\n",
        "    beta = np.atleast_1d(np.asarray(beta))\n",
        "    Xb = np.dot(X, beta).astype(np.float64)\n",
        "    Xb_clipped = np.clip(Xb, a_min=None, a_max=20)  # cap max exponent\n",
        "    lam = np.exp(Xb_clipped)\n",
        "\n",
        "    return np.sum(-lam + Y * Xb - gammaln(Y + 1))\n",
        "\n",
        "def neg_loglike(beta, X, Y):\n",
        "    return -poisson_loglike(beta, X, Y)\n",
        "\n",
        "\n",
        "initial_beta = np.zeros(X.shape[1])\n",
        "result = optimize.minimize(neg_loglike, initial_beta, args=(X_matrix, Y), method='BFGS')\n",
        "beta_hat = result.x\n",
        "hessian_inv = result.hess_inv\n",
        "std_errs = np.sqrt(np.diag(hessian_inv))\n",
        "summary = pd.DataFrame({\n",
        "    \"Coefficient\": beta_hat,\n",
        "    \"Std. Error\": std_errs\n",
        "}, index=X.columns)\n",
        "\n",
        "summary"
      ],
      "id": "4c8d2791",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::::\n",
        "\n",
        "### Validate Results Using `statsmodels.GLM()`\n",
        "\n",
        "To confirm the accuracy of our manual MLE implementation, we use `statsmodels.GLM()` to estimate the same Poisson regression model:\n",
        "\n",
        "::::{.callout-note collapse=\"true\"}"
      ],
      "id": "a7007392"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import statsmodels.api as sm\n",
        "\n",
        "# Drop 'intercept' column and ensure all data is float\n",
        "X_glm = X.drop(columns='intercept', errors='ignore').astype(float)\n",
        "\n",
        "# Add constant for intercept term\n",
        "X_glm = sm.add_constant(X_glm)\n",
        "\n",
        "# Fit GLM model\n",
        "glm_model = sm.GLM(Y, X_glm, family=sm.families.Poisson())\n",
        "glm_results = glm_model.fit()\n",
        "\n",
        "# Display summary\n",
        "glm_results.summary()\n",
        "\n",
        "### Coefficients and Standard Errors from Poisson Regression\n",
        "# Extract coefficient summary\n",
        "coef_table = glm_results.summary2().tables[1][[\"Coef.\", \"Std.Err.\"]]\n",
        "coef_table.rename(columns={\"Coef.\": \"Coefficient\", \"Std.Err.\": \"Std. Error\"}, inplace=True)\n",
        "\n",
        "# Display table\n",
        "coef_table"
      ],
      "id": "60a8c4e4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::::\n",
        "\n",
        "### Interpretation \n",
        "- **Age** has a strong positive effect on patent activity: older firms are more likely to have more patents.\n",
        "- **Age²** is negative and significant, suggesting a diminishing return — patent output increases with age but at a decreasing rate.\n",
        "- **Blueprinty’s software** has a statistically significant positive coefficient of 0.2076 (p < 0.001). This implies firms using the software are expected to have **23% more patents** than comparable non-customers.\n",
        "- **Regional effects** (Northeast, Northwest, etc.) are not statistically significant, suggesting location does not materially affect patent outcomes once other factors are controlled for.\n",
        "\n",
        "Estimate Effect of Blueprinty's Software via **Counterfactual Prediction**\n",
        "\n",
        "We simulate two scenarios:\n",
        "\n",
        "- `X_0`: All firms set to **non-customer** (`iscustomer = 0`)\n",
        "- `X_1`: All firms set to **customer** (`iscustomer = 1`)\n",
        "\n",
        "Then we compare the predicted number of patents for each firm under the two scenarios using the fitted model."
      ],
      "id": "c33eefe5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Make two versions of X_glm:\n",
        "# X_0: all firms are non-customers\n",
        "# X_1: all firms are customers\n",
        "X_0 = X_glm.copy()\n",
        "X_1 = X_glm.copy()\n",
        "\n",
        "X_0[\"iscustomer\"] = 0\n",
        "X_1[\"iscustomer\"] = 1\n",
        "\n",
        "# Predict expected patent counts\n",
        "y_pred_0 = glm_results.predict(X_0)\n",
        "y_pred_1 = glm_results.predict(X_1)\n",
        "\n",
        "# Estimate average treatment effect\n",
        "average_effect = np.mean(y_pred_1 - y_pred_0)"
      ],
      "id": "7824355c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Interpretation\n",
        "The average difference in predicted number of patents between Blueprinty customers and non-customers is:"
      ],
      "id": "0972eea4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(f\"Estimated average increase in patent count from using Blueprinty: {average_effect:.3f}\")"
      ],
      "id": "27f39e28",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This quantifies the effect of Blueprinty's software: firms using it are predicted to file approximately **0.793** more patents over 5 years, on average, than similar firms who don’t use it, controlling for age and region.\n",
        "\n",
        "## AirBnB Case Study\n",
        "### Introduction\n",
        "\n",
        "AirBnB is a popular platform for booking short-term rentals. In March 2017, students Annika Awad, Evan Lebo, and Anna Linden scraped of 40,000 Airbnb listings from New York City.  The data include the following variables:\n",
        "\n",
        ":::: {.callout-note collapse=\"true\"}\n",
        "### Variable Definitions\n",
        "\n",
        "    - `id` = unique ID number for each unit\n",
        "    - `last_scraped` = date when information scraped\n",
        "    - `host_since` = date when host first listed the unit on Airbnb\n",
        "    - `days` = `last_scraped` - `host_since` = number of days the unit has been listed\n",
        "    - `room_type` = Entire home/apt., Private room, or Shared room\n",
        "    - `bathrooms` = number of bathrooms\n",
        "    - `bedrooms` = number of bedrooms\n",
        "    - `price` = price per night (dollars)\n",
        "    - `number_of_reviews` = number of reviews for the unit on Airbnb\n",
        "    - `review_scores_cleanliness` = a cleanliness score from reviews (1-10)\n",
        "    - `review_scores_location` = a \"quality of location\" score from reviews (1-10)\n",
        "    - `review_scores_value` = a \"quality of value\" score from reviews (1-10)\n",
        "    - `instant_bookable` = \"t\" if instantly bookable, \"f\" if not\n",
        "::::\n",
        "\n",
        "### Data Cleaning\n",
        "\n",
        "We begin by dropping listings with missing values in relevant variables, then perform basic EDA on the cleaned dataset.\n",
        "\n",
        "### Drop Rows with Missing Data"
      ],
      "id": "3c2e4ba0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import pandas as pd\n",
        "df = pd.read_csv(\"airbnb.csv\")\n",
        "relevant_cols = [\n",
        "    \"number_of_reviews\", \"room_type\", \"bathrooms\", \"bedrooms\", \"price\", \"days\",\n",
        "    \"review_scores_cleanliness\", \"review_scores_location\", \"review_scores_value\", \"instant_bookable\"\n",
        "]\n",
        "df_clean = df[relevant_cols].dropna()"
      ],
      "id": "fb881f5c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Exploratory Data Analysis (EDA)\n",
        "\n",
        "### Distribution of Number of Reviews"
      ],
      "id": "1ada4de3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "\n",
        "plt.figure(figsize=(8, 6))\n",
        "sns.histplot(\n",
        "    df_clean[\"number_of_reviews\"],\n",
        "    bins=50,\n",
        "    kde=False,\n",
        "    color=\"#1F78B4\",\n",
        "\n",
        ")\n",
        "\n",
        "plt.title(\"Distribution of Number of Reviews\", fontsize=14, weight=\"bold\")\n",
        "plt.xlabel(\"Number of Reviews\", fontsize=12)\n",
        "plt.ylabel(\"Count of Listings\", fontsize=12)\n",
        "plt.xlim(0, 100)\n",
        "plt.grid(axis=\"y\", linestyle=\"--\", alpha=0.5)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "41589caa",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Average Number of Reviews by Room Type "
      ],
      "id": "321cfeb1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "import warnings\n",
        "\n",
        "# Data\n",
        "avg_reviews = df_clean.groupby(\"room_type\")[\"number_of_reviews\"].mean().reset_index()\n",
        "\n",
        "# Better-looking custom blue palette\n",
        "custom_blue_palette = [\"#A6CEE3\", \"#1F78B4\", \"#08519C\"]\n",
        "\n",
        "# Plot with warning suppression\n",
        "with warnings.catch_warnings():\n",
        "    warnings.simplefilter(\"ignore\", category=FutureWarning)\n",
        "\n",
        "    plt.figure(figsize=(8, 6))\n",
        "    sns.barplot(\n",
        "        data=avg_reviews,\n",
        "        x=\"room_type\",\n",
        "        y=\"number_of_reviews\",\n",
        "        palette=custom_blue_palette,\n",
        "    )\n",
        "\n",
        "plt.title(\"Average Number of Reviews by Room Type\", fontsize=14, weight=\"bold\")\n",
        "plt.xlabel(\"Room Type\", fontsize=12)\n",
        "plt.ylabel(\"Average Number of Reviews\", fontsize=12)\n",
        "plt.xticks(rotation=0)\n",
        "plt.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "16626017",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Average Number of Reviews by Instant Bookability"
      ],
      "id": "59035e16"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "import warnings\n",
        "avg_reviews_by_bookable = df_clean.groupby(\"instant_bookable\")[\"number_of_reviews\"].mean().reset_index()\n",
        "avg_reviews_by_bookable[\"instant_bookable\"] = avg_reviews_by_bookable[\"instant_bookable\"].map({\"f\": \"No\", \"t\": \"Yes\"})\n",
        "\n",
        "blue_palette = {\"No\": \"#6baed6\", \"Yes\": \"#2171b5\"}\n",
        "with warnings.catch_warnings():\n",
        "    warnings.simplefilter(\"ignore\")\n",
        "\n",
        "    plt.figure(figsize=(8, 6))\n",
        "    sns.barplot(\n",
        "        data=avg_reviews_by_bookable,\n",
        "        x=\"instant_bookable\",\n",
        "        y=\"number_of_reviews\",\n",
        "        hue=\"instant_bookable\", \n",
        "        palette=blue_palette,\n",
        "        legend=False,\n",
        "    )\n",
        "plt.title(\"Average Number of Reviews by Instant Bookability\", fontsize=14, weight=\"bold\")\n",
        "plt.xlabel(\"Instant Bookable\", fontsize=12)\n",
        "plt.ylabel(\"Average Number of Reviews\", fontsize=12)\n",
        "plt.ylim(0, avg_reviews_by_bookable[\"number_of_reviews\"].max() * 1.1)\n",
        "plt.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "81cf09b0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Correlation with Numeric Predictors"
      ],
      "id": "36da8794"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import seaborn as sns\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "numeric_vars = [\n",
        "    \"number_of_reviews\", \"bathrooms\", \"bedrooms\", \"price\", \"days\",\n",
        "    \"review_scores_cleanliness\", \"review_scores_location\", \"review_scores_value\"\n",
        "]\n",
        "correlation_matrix = df_clean[numeric_vars].corr()\n",
        "plt.figure(figsize=(10, 8))\n",
        "sns.heatmap(\n",
        "    correlation_matrix,\n",
        "    annot=True,\n",
        "    fmt=\".2f\",\n",
        "    cmap=\"Blues\",             \n",
        "    vmin=0, vmax=1,          \n",
        "    square=True,\n",
        "    linewidths=0.75,\n",
        "    linecolor=\"white\",\n",
        "    annot_kws={\"fontsize\": 10, \"weight\": \"bold\"}\n",
        ")\n",
        "plt.title(\"Correlation Matrix of Numeric Variables\", fontsize=14, weight=\"bold\")\n",
        "plt.xticks(rotation=45, ha=\"right\", fontsize=10)\n",
        "plt.yticks(rotation=0, fontsize=10)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "c9036490",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Poisson Regression Model Using `statsmodels.GLM()`\n",
        "\n",
        "We model the number of reviews (as a proxy for bookings) using a Poisson regression with the following predictors:\n",
        "- `room_type` (categorical)\n",
        "- `instant_bookable` (binary)\n",
        "- `price`, `days`, `bathrooms`, `bedrooms`\n",
        "- Review scores: `cleanliness`, `location`, `value`"
      ],
      "id": "472fcaee"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import statsmodels.api as sm\n",
        "\n",
        "room_dummies = pd.get_dummies(df_clean[\"room_type\"], drop_first=True)\n",
        "df_clean[\"instant_bookable\"] = df_clean[\"instant_bookable\"].map({\"t\": 1, \"f\": 0})\n",
        "\n",
        "# Create design matrix\n",
        "X = pd.concat([\n",
        "    df_clean[[\"price\", \"days\", \"bathrooms\", \"bedrooms\",\n",
        "              \"review_scores_cleanliness\", \"review_scores_location\", \"review_scores_value\",\n",
        "              \"instant_bookable\"]],\n",
        "    room_dummies\n",
        "], axis=1)\n",
        "\n",
        "X = sm.add_constant(X)\n",
        "X = X.astype(float)  \n",
        "\n",
        "Y = df_clean[\"number_of_reviews\"]\n",
        "\n",
        "poisson_model = sm.GLM(Y, X, family=sm.families.Poisson())\n",
        "poisson_results = poisson_model.fit()\n",
        "summary_df = poisson_results.summary2().tables[1]\n",
        "\n",
        "summary_df = summary_df.rename(columns={\n",
        "    \"Coef.\": \"Coefficient\",\n",
        "    \"Std.Err.\": \"Std. Error\",\n",
        "    \"P>|z|\": \"P-Value\"\n",
        "})\n",
        "\n",
        "significant_results = summary_df[summary_df[\"P-Value\"] < 0.05][[\"Coefficient\", \"Std. Error\", \"P-Value\"]]\n",
        "\n",
        "significant_results = significant_results.round(4)\n",
        "\n",
        "significant_results"
      ],
      "id": "ef29cc6f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Interpretation\n",
        "- **Intercept (`3.4980`)**  \n",
        "  The baseline log-expected number of reviews for a listing when all other variables are zero (serves as a reference point).\n",
        "\n",
        "- **Price (`-0.0000`)**  \n",
        "  As price increases, the expected number of reviews decreases slightly. This effect is small but statistically significant, indicating higher-priced listings may deter some bookings.\n",
        "\n",
        "- **Days Active (`+0.0001`)**  \n",
        "  Listings that have been active longer tend to accumulate more reviews. This reflects more exposure over time.\n",
        "\n",
        "- **Bathrooms (`-0.1177`)**  \n",
        "  Surprisingly, listings with more bathrooms tend to receive fewer reviews. This might reflect that larger or luxury properties are booked less frequently.\n",
        "\n",
        "- **Bedrooms (`+0.0741`)**  \n",
        "  Listings with more bedrooms attract more bookings, likely due to their ability to accommodate larger groups.\n",
        "\n",
        "- **Cleanliness Score (`+0.1131`)**  \n",
        "  Clean listings receive more reviews, reinforcing the importance of cleanliness to guests.\n",
        "\n",
        "- **Location Score (`-0.0769`)**  \n",
        "  A negative association with reviews, possibly due to limited variation in location ratings or multicollinearity with other variables.\n",
        "\n",
        "- **Value Score (`-0.0911`)**  \n",
        "  Higher value scores are associated with fewer reviews, which may reflect that guests leave high value ratings in less competitive or less popular markets.\n",
        "\n",
        "- **Instant Bookable (`+0.3459`)**  \n",
        "  Listings that support instant booking are expected to receive approximately **41% more reviews** than those that do not:  \n",
        "  \\[\n",
        "  \\exp(0.3459) \\approx 1.41\n",
        "  \\]\n",
        "- **Private Room (`-0.0105`)**  \n",
        "  Private rooms receive slightly fewer reviews than entire homes, likely due to lower demand or guest preferences for full space.\n",
        "\n",
        "- **Shared Room (`-0.2463`)**  \n",
        "  Shared rooms receive significantly fewer reviews — about **22% fewer** than entire homes:  \n",
        "  \\[\n",
        "  \\exp(-0.2463) \\approx 0.78\n",
        "  \\]\n"
      ],
      "id": "7e165f4e"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/opt/conda/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}